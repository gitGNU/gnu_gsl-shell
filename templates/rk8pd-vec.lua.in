
# -- num/rk8pd.lua.in
# --
# -- Copyright (C) 2009-2011 Francesco Abbate
# --
# -- This program is free software; you can redistribute it and/or modify
# -- it under the terms of the GNU General Public License as published by
# -- the Free Software Foundation; either version 3 of the License, or (at
# -- your option) any later version.
# --
# -- This program is distributed in the hope that it will be useful, but
# -- WITHOUT ANY WARRANTY; without even the implied warranty of
# -- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# -- General Public License for more details.
# --
# -- You should have received a copy of the GNU General Public License
# -- along with this program; if not, write to the Free Software
# -- Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
# --

# -- Adapted from the GSL Library, version 1.14

# -- Runge-Kutta 8(9), Prince-Dormand
# --
# -- High Order Embedded Runge-Kutta Formulae
# -- P.J. Prince and J.R. Dormand
# -- J. Comp. Appl. Math.,7, pp. 67-75, 1981

# -- Original author:  G. Jungman
# -- Modified for LuaJIT2: Francesco Abbate

local abs, max, min = math.abs, math.max, math.min

# order = 8

local gsl = require 'gsl'

local function hadjust(rmax, h)
   local S = 0.9
   if rmax > 1.1 then
      local r = S / rmax^(1/$(order))
      r = max(0.2, r)
      return r * h, -1
   elseif rmax < 0.5 then
      local r = S / rmax^(1/($(order)+1))
      r = max(1, min(r, 5))
      return r * h, 1
   end
   return h, 0
end


# Abar = { '14005451/335480064',
#	   '0',
#	   '0',
#	   '0',
#	   '0',
#          '-59238493/1068277825',
#	   '181606767/758867731',
#	   '561292985/797845732',
#          '-1041891430/1371343529',
#	   '760417239/1151165299',
#	   '118820643/751138087',
#          '-528747749/2220607170',
#	   '1/4' }

# A = {
#    '13451932/455176623',
#    '0',
#    '0',
#    '0',
#    '0',
#    '-808719846/976000145',
#    '1757004468/5645159321',
#    '656045339/265891186',
#    '-3867574721/1518517206',
#    '465885868/322736535',
#    '53011238/667516719',
#    '2/45' }

# ah = {
#    '1/18',
#    '1/12',
#    '1/8',
#    '5/16',
#    '3/8',
#    '59/400',
#    '93/200',
#    '5490023248/9719169821',
#    '13/20',
#    '1201146811/1299019798',
#    '1',
#    '1' }

# B = { 0 }
# B[2] = { '1/18' }
# B[3] = { '1/48', '1/16' }
# B[4] = { '1/32', '0', '3/32' }
# B[5] = { '5/16', '0', '-75/64', '75/64' }
# B[6] = { '3/80', '0', '0', '3/16', '3/20' }
# B[7] = {
#    '29443841/614563906',
#    '0',
#    '0',
#    '77736538/692538347',
#    '-28693883/1125000000',
#    '23124283/1800000000' }

# B[8] = {
#    '16016141/946692911',
#    '0',
#    '0',
#    '61564180/158732637',
#    '22789713/633445777',
#    '545815736/2771057229',
#    '-180193667/1043307555' }

# B[9] = {
#    '39632708/573591083',
#    '0',
#    '0',
#    '-433636366/683701615',
#    '-421739975/2616292301',
#    '100302831/723423059',
#    '790204164/839813087',
#    '800635310/3783071287' }

# B[10] = {
#    '246121993/1340847787',
#    '0',
#    '0',
#    '-37695042795/15268766246',
#    '-309121744/1061227803',
#    '-12992083/490766935',
#    '6005943493/2108947869',
#    '393006217/1396673457',
#    '123872331/1001029789' }

# B[11] = {
#    '-1028468189/846180014',
#    '0',
#    '0',
#    '8478235783/508512852',
#    '1311729495/1432422823',
#    '-10304129995/1701304382',
#    '-48777925059/3047939560',
#    '15336726248/1032824649',
#    '-45442868181/3398467696',
#    '3065993473/597172653' }

# B[12] = {
#    '185892177/718116043',
#    '0',
#    '0',
#    '-3185094517/667107341',
#    '-477755414/1098053517',
#    '-703635378/230739211',
#    '5731566787/1027545527',
#    '5232866602/850066563',
#    '-4093664535/808688257',
#    '3962137247/1805957418',
#    '65686358/487910083' }

# B[13] = {
#    '403863854/491063109',
#    '0',
#    '0',
#    '-5068492393/434740067',
#    '-411421997/543043805',
#    '652783627/914296604',
#    '11173962825/925320556',
#    '-13158990841/6184727034',
#    '3936647629/1978049680',
#    '-160528059/685178525',
#    '248638103/1413531060',
#    '0' }

# y_err_only = (a_dydt == 0)

local function copy(dst, src)
   gsl.cblas_dcopy($(N), src, 1, dst, 1)
end

local function axpy(alpha, x, y)
   gsl.cblas_daxpy($(N), alpha, x, 1, y, 1)
end

local function view(m, i)
   return m.data + m.tda * i
end

local function zero(x)
   for i = 0, $(N-1) do x[i] = 0 end
end

local function rk8pd_vec_evolve(s, f, t1)
   local t, h, s_y, s_dydt = s.t, s.h, s.y, s.dydt
   local hadj, inc

#  for S = 1, 13 do
      local k$(S) = s.k$(S)
#  end

   local y = s.ytmp1
   copy(k1.data, s_dydt.data)

   if t + h > t1 then h = t1 - t end

   while h > 0 do
      copy(y.data, s_y.data)
      local rmax = 0

      do
      local ytmp = s.ytmp2

#     for S = 2, 13 do
         copy(ytmp.data, y.data)
#        for J = 1, S-1 do
	    axpy(h * $(B[S][J]), k$(J).data, ytmp.data)
#        end
         f(t + $(ah[S-1]) * h, ytmp, k$(S))
#     end

      local ksum8 = s.ksum8.data
      zero(ksum8)
#     for S = 1, 13 do
         axpy($(Abar[S]), k$(S).data, ksum8)
#     end
      axpy(h, ksum8, y.data)

#     if not y_err_only then
         f(t + h, y, s_dydt)
#     end

      do
      local yerr

      for i = 0, $(N-1) do
         local ksum7 = 0
#        for S = 1, 12 do
            ksum7 = ksum7 + $(A[S]) * k$(S).data[i]
#        end
         yerr = h * (ksum7 - ksum8[i])
#     if y_err_only then
         d0 = $(eps_rel) * ($(a_y) * abs(y.data[i])) + $(eps_abs)
#     else
         d0 = $(eps_rel) * ($(a_y) * abs(y.data[i])) + $(a_dydt) * abs(h * s_dydt.data[i]) + $(eps_abs)
#     end
         r = abs(yerr) / abs(d0)
         rmax = max(r, rmax)
      end
      end
      end

      hadj, inc = hadjust(rmax, h)
      if inc >= 0 then break end

      h = hadj
   end

#  if y_err_only then
      f(t + h, y, s_dydt)
#  end

   copy(s_y.data, y.data)
   s.t = t + h
   s.h = hadj

   return h
end

local function ode_vec_new()
   local n = $(N)
   return {t    = 0,
	   h    = 1,
	   dim  = n,
	   y    = matrix.new(n, 1),
	   dydt = matrix.new(n, 1),
#          for J = 1, 13 do
	      k$(J) = matrix.new(n, 1),
#          end
	   ksum8 = matrix.new(n, 1),
	   ytmp1 = matrix.new(n, 1),
	   ytmp2 = matrix.new(n, 1),
	}
end

local function ode_vec_init(s, t0, h0, f, y)
   copy(s.y.data, y.data)
   f(t0, y, s.dydt)
   s.t = t0
   s.h = h0
end

return {new= ode_vec_new, init= ode_vec_init, evolve= rk8pd_vec_evolve}
